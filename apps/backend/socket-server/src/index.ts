import { createServer } from 'http';
import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import env from './config/env.js';
import { redis, redisPub, redisSub } from '@/lib/redis';
import { authMiddleware } from './middleware/auth.js';
import { registerPostHandlers } from './handlers/postHandlers.js';
import { registerCommentHandlers } from './handlers/commentHandlers.js';
import { registerFeedHandlers } from './handlers/feedHandlers.js';
import { registerTypingHandlers } from './handlers/typingHandlers.js';
import { registerNotificationHandlers } from './handlers/notificationHandlers.js';
import { PresenceService } from './services/presenceService.js';
import type {
  ServerToClientEvents,
  ClientToServerEvents,
  InterServerEvents,
  SocketData,
} from '@/types';

const httpServer = createServer();

const io: Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData> = new Server(httpServer, {
  cors: {
    origin: env.CORS_ORIGIN.split(','),
    methods: ['GET', 'POST'],
    credentials: true,
  },
  transports: ['websocket', 'polling'],
  pingTimeout: 60000,
  pingInterval: 25000,
});

// Setup Redis adapter for scaling across multiple instances
io.adapter(createAdapter(redisPub, redisSub));

// Authentication middleware
io.use(authMiddleware);

// Optional: listen to Redis pub/sub channel for notifications generated by other services
redisSub.subscribe('notifications').catch((err) => {
  console.error('Failed to subscribe to notifications channel', err);
});

redisSub.on('message', (channel, message) => {
  if (channel !== 'notifications') return;
  try {
    const payload = JSON.parse(message);
    const { userId, notification } = payload;
    if (!userId || !notification) return;
    io.to(`user:${userId}`).emit('notification:new', { notification });
  } catch (err) {
    console.error('Error handling notification message', err);
  }
});

// Add this before io.on('connection')
httpServer.on('request', (req, res) => {
  if (req.url === '/health' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ 
      status: 'ok', 
      timestamp: new Date().toISOString(),
      uptime: process.uptime()
    }));
  }
});

// Connection handler
io.on('connection', async (socket) => {
  console.log(`âœ… User connected: ${socket.data.userId} (${socket.id})`);

  try {
    // âœ… Pass socketId to track multiple connections
    await PresenceService.setUserOnline(socket.data.userId, socket.id);

    await socket.join(`user:${socket.data.userId}`);

    io.emit('user:online', {
      userId: socket.data.userId,
      username: socket.data.username,
      timestamp: new Date().toISOString(),
    });

    // Register event handlers
    registerPostHandlers(io, socket);
    registerCommentHandlers(io, socket);
    registerFeedHandlers(io, socket);
    registerTypingHandlers(io, socket);
    registerNotificationHandlers(io, socket);

    socket.on('disconnect', async (reason) => {
      console.log(`âŒ User disconnected: ${socket.data.userId} (${reason})`);

      try {
        // âœ… Pass socketId to only remove this connection
        await PresenceService.setUserOffline(socket.data.userId, socket.id);

        // Check if user is actually offline (no other connections)
        const isStillOnline = await PresenceService.isUserOnline(socket.data.userId);
        
        if (!isStillOnline) {
          io.emit('user:offline', {
            userId: socket.data.userId,
            username: socket.data.username,
            timestamp: new Date().toISOString(),
          });
        }
      } catch (error) {
        console.error('Error handling disconnect:', error);
      }
    });

  } catch (error) {
    console.error('Error in connection handler:', error);
    socket.disconnect();
  }
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, closing server...');
  
  io.close(() => {
    console.log('Socket.IO server closed');
  });

  await redis.quit();
  await redisPub.quit();
  await redisSub.quit();
  
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('SIGINT received, closing server...');
  
  io.close(() => {
    console.log('Socket.IO server closed');
  });

  await redis.quit();
  await redisPub.quit();
  await redisSub.quit();
  
  process.exit(0);
});

// Start server
const PORT = parseInt(env.PORT, 10);

httpServer.listen(PORT, () => {
  console.log(`ðŸš€ Socket.IO server running on port ${PORT}`);
  console.log(`ðŸ“¡ Environment: ${env.NODE_ENV}`);
  console.log(`ðŸ”— CORS Origin: ${env.CORS_ORIGIN}`);
});