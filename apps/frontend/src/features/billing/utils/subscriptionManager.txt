import { Prisma, SubscriptionStatus, PaymentStatus, BillingType, PaymentMethod } from '@xovira/types';
import { prisma } from '@/lib/prisma';
import { DateTime } from 'luxon';
import { PlanManager } from './planManager';
import { UsageManager } from '../../usage/utils/usageManager';

type SubscribeInput = {
  userId: string;
  planId: string;
  providerName: string;
  status: string;
  intentId?: string;
  chargeId?: string;
  refundId?: string;
  errorMessage?: string;
  metadata?: Record<string, any>;
};

export class SubscriptionManager {
  private static readonly TRANSACTION_TIMEOUT = 50000;
  private static readonly MAX_WAIT = 5000;

  private static getPaymentStatus(status: string): PaymentStatus {
    switch (status) {
      case 'COMPLETED':
      case 'ACTIVE':
        return PaymentStatus.SUCCEEDED;
      case 'PENDING':
        return PaymentStatus.PENDING;
      case 'FAILED':
      case 'DENIED':
        return PaymentStatus.FAILED;
      case 'CANCELLED':
        return PaymentStatus.CANCELED;
      case 'REFUNDED':
        return PaymentStatus.REFUNDED;
      case 'EXPIRED':
        return PaymentStatus.EXPIRED;
      default:
        throw new Error(`Unknown gateway status: ${status}`);
    }
  }

  private static getSubscriptionStatus(status: string): SubscriptionStatus {
    switch (status) {
      case 'COMPLETED':
      case 'ACTIVE':
        return SubscriptionStatus.ACTIVE;
      case 'PENDING':
      case 'FAILED':
      case 'DENIED':
      case 'CANCELLED':
      case 'REFUNDED':
      case 'EXPIRED':
        return SubscriptionStatus.CANCELED;
      default:
        throw new Error(`Unknown gateway status: ${status}`);
    }
  }

  static async getCurrentSubscription(userId: string) {
    if (!userId) throw new Error('User not found');
    return prisma.subscription.findFirst({
      where: { userId, status: { in: [SubscriptionStatus.ACTIVE, SubscriptionStatus.PAUSED] } },
      orderBy: { currentPeriodStart: 'desc' },
      include: { plan: { include: { feature: true } }, payments: true }
    });
  }

  static async getSubscriptionDetails(userId: string) {
    const subscription = await this.getCurrentSubscription(userId);
    if (!subscription) return null;
    const cycle = await this.checkAndManageCycle(userId);
    const latestPayment = subscription.payments[subscription.payments.length - 1];
    return {
      status: subscription.status,
      plan: {
        name: subscription.plan.name,
        price: subscription.plan.price,
        billingType: subscription.plan.planType,
        interval: subscription.plan.billingPeriod,
        feature: subscription.plan.feature
      },
      currentPeriodStart: subscription.currentPeriodStart,
      currentPeriodEnd: subscription.currentPeriodEnd,
      canceledAt: subscription.canceledAt,
      cancelReason: subscription.cancelReason,
      daysUntilExpiration: cycle.daysUntilExpiration,
      isCycleTransition: cycle.isExpired,
      nextCycleStart: cycle.nextCycleStart,
      nextCycleEnd: cycle.nextCycleEnd,
      latestPayment: latestPayment
        ? {
            status: latestPayment.status,
            amount: latestPayment.amount,
            billingType: latestPayment.billingType,
            currency: latestPayment.currency,
            billingPeriodStart: latestPayment.billingPeriodStart,
            billingPeriodEnd: latestPayment.billingPeriodEnd
          }
        : undefined
    };
  }

  static async subscribe(data: SubscribeInput) {
    if (!data.userId || !data.planId || !data.status) {
      throw new Error('Missing required subscription data');
    }
    const plan = await PlanManager.getPlan(data.planId);
    if (!plan) throw new Error('Invalid subscription plan');

    const currentPeriodStart = DateTime.now();
    const currentPeriodEnd = currentPeriodStart.plus({ months: 1 });
    const paymentStatus = this.getPaymentStatus(data.status);
    const subscriptionStatus = this.getSubscriptionStatus(data.status);

    const created = await prisma.$transaction(
      async (tx) => {
        if (paymentStatus === PaymentStatus.SUCCEEDED) {
          await tx.subscription.updateMany({
            where: { userId: data.userId, status: { in: [SubscriptionStatus.ACTIVE, SubscriptionStatus.PAUSED] } },
            data: { status: SubscriptionStatus.EXPIRED, currentPeriodEnd: currentPeriodStart.toJSDate() }
          });
        }
        const feature = plan.feature;
        const usage = await tx.usage.create({
          data: {
            userId: data.userId,
            maxProjects: feature?.maxProjects || 0,
            remainingProjects: feature?.maxProjects || 0,
            maxTeams: feature?.maxTeams || 0,
            remainingTeams: feature?.maxTeams || 0,
            maxProposals: feature?.maxProposals || 0,
            remainingProposals: feature?.maxProposals || 0,
            maxRequests: feature?.maxRequests || 0,
            remainingRequests: feature?.maxRequests || 0,
            maxCredits: feature?.maxCredits || 0,
            remainingCredits: feature?.maxCredits || 0
          }
        });
        const subscription = await tx.subscription.create({
          data: {
            userId: data.userId,
            planId: plan.id,
            usageId: usage.id,
            status: subscriptionStatus,
            currentPeriodStart: currentPeriodStart.toJSDate(),
            currentPeriodEnd: currentPeriodEnd.toJSDate()
          },
          include: { plan: { include: { feature: true } }, payments: true }
        });
        await tx.payment.create({
          data: {
            userId: data.userId,
            subscriptionId: subscription.id,
            billingType: BillingType.SUBSCRIPTION,
            paymentMethod: PaymentMethod.OTHER,
            amount: plan.price,
            currency: plan.currency,
            status: paymentStatus,
            billingPeriodStart: currentPeriodStart.toJSDate(),
            billingPeriodEnd: currentPeriodEnd.toJSDate(),
            intentId: data.intentId || undefined,
            chargeId: data.chargeId || undefined,
            refundId: data.refundId || undefined,
            failureReason: data.errorMessage,
            metadata: data.metadata
          }
        });
        return subscription;
      },
      { timeout: this.TRANSACTION_TIMEOUT, maxWait: this.MAX_WAIT, isolationLevel: Prisma.TransactionIsolationLevel.Serializable }
    );

    return created;
  }

  static async update(userId: string, newPlanId: string) {
    await prisma.$transaction(
      async (tx) => {
        const current = await this.getCurrentSubscription(userId);
        if (current) {
          await tx.subscription.update({ where: { id: current.id }, data: { status: SubscriptionStatus.CANCELED, currentPeriodEnd: new Date() } });
        }
      },
      { maxWait: this.MAX_WAIT, isolationLevel: Prisma.TransactionIsolationLevel.Serializable, timeout: this.TRANSACTION_TIMEOUT }
    );
    return this.subscribe({ userId, planId: newPlanId, providerName: 'INTERNAL', status: 'ACTIVE' });
  }

  static async createDefaultSubscription(userId: string) {
    if (!userId) throw new Error('User not found');
    const existing = await this.getCurrentSubscription(userId);
    if (existing) return existing;
    const freePlan = await prisma.plan.findFirst({ where: { name: 'FREE', isActive: true }, include: { feature: true } });
    if (!freePlan) throw new Error('Free plan not found in the system');
    const currentPeriodStart = DateTime.now().startOf('day');
    const currentPeriodEnd = currentPeriodStart.plus({ months: 1 });
    const usage = await prisma.usage.create({
      data: {
        userId,
        maxProjects: freePlan.feature?.maxProjects || 0,
        remainingProjects: freePlan.feature?.maxProjects || 0,
        maxTeams: freePlan.feature?.maxTeams || 0,
        remainingTeams: freePlan.feature?.maxTeams || 0,
        maxProposals: freePlan.feature?.maxProposals || 0,
        remainingProposals: freePlan.feature?.maxProposals || 0,
        maxRequests: freePlan.feature?.maxRequests || 0,
        remainingRequests: freePlan.feature?.maxRequests || 0,
        maxCredits: freePlan.feature?.maxCredits || 0,
        remainingCredits: freePlan.feature?.maxCredits || 0
      }
    });
    return prisma.subscription.create({
      data: { userId, planId: freePlan.id, usageId: usage.id, status: SubscriptionStatus.ACTIVE, currentPeriodStart: currentPeriodStart.toJSDate(), currentPeriodEnd: currentPeriodEnd.toJSDate() },
      include: { plan: true, payments: true }
    });
  }

  static async renew(userId: string) {
    const current = await this.getCurrentSubscription(userId);
    if (!current) throw new Error('No subscription found');
    if (current.plan.name === 'FREE') throw new Error('Cannot renew a free plan');
    const currentPeriodStart = DateTime.now();
    const currentPeriodEnd = currentPeriodStart.plus({ months: 1 });
    return prisma.$transaction(
      async (tx) => {
        await tx.subscription.update({ where: { id: current.id }, data: { currentPeriodStart: currentPeriodStart.toJSDate(), currentPeriodEnd: currentPeriodEnd.toJSDate(), status: SubscriptionStatus.ACTIVE } });
        await tx.payment.create({
          data: {
            userId,
            subscriptionId: current.id,
            amount: current.plan.price,
            currency: current.plan.currency,
            billingType: BillingType.SUBSCRIPTION,
            paymentMethod: PaymentMethod.OTHER,
            status: PaymentStatus.PENDING,
            billingPeriodStart: currentPeriodStart.toJSDate(),
            billingPeriodEnd: currentPeriodEnd.toJSDate()
          }
        });
        return current;
      },
      { maxWait: this.MAX_WAIT, isolationLevel: Prisma.TransactionIsolationLevel.Serializable, timeout: this.TRANSACTION_TIMEOUT }
    );
  }

  static async activate(
    userId: string,
    details: {
      subscriptionId: string;
      status: SubscriptionStatus;
      planId?: string;
      planName?: string;
      providerName?: string;
      createdAt?: string;
      updatedAt?: string;
      metadata?: Record<string, any>;
    }
  ) {
    if (!userId) throw new Error('User not found');
    let targetPlanId: string | null = null;
    if (details.planId) {
      targetPlanId = details.planId;
    } else if (details.planName) {
      const plan = await prisma.plan.findFirst({ where: { name: details.planName, isActive: true }, select: { id: true } });
      targetPlanId = plan?.id || null;
    }
    return prisma.$transaction(
      async (tx) => {
        const current = await this.getCurrentSubscription(userId);

        // If we know the target plan and the user is already on it, abort with an error
        if (current && targetPlanId && current.plan?.id === targetPlanId) {
          throw new Error('User is already subscribed to the selected plan');
        }

        // Otherwise, subscribe anew using the resolved plan
        if (!targetPlanId) {
          throw new Error('Target plan not resolved for activation');
        }

        const created = await SubscriptionManager.subscribe({
          userId,
          planId: targetPlanId,
          providerName: details.providerName || 'INTERNAL',
          status: 'ACTIVE',
          chargeId: details.subscriptionId,
          metadata: details.metadata
        });

        return created;
      },
      { maxWait: this.MAX_WAIT, isolationLevel: Prisma.TransactionIsolationLevel.Serializable, timeout: this.TRANSACTION_TIMEOUT }
    );
  }

  static async freeze(userId: string) {
    const current = await this.getCurrentSubscription(userId);
    if (!current) throw new Error('No subscription found to freeze');
    return prisma.subscription.update({ where: { id: current.id }, data: { status: SubscriptionStatus.PAUSED }, include: { payments: true, plan: true } });
  }

  static async unfreeze(userId: string) {
    const current = await this.getCurrentSubscription(userId);
    if (!current) throw new Error('No subscription found to unfreeze');
    return prisma.subscription.update({ where: { id: current.id }, data: { status: SubscriptionStatus.ACTIVE }, include: { payments: true, plan: true } });
  }

  static async reset(userId: string) {
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (!user) throw new Error('User not found');
    await prisma.$transaction(
      async (tx) => {
        await tx.subscription.updateMany({ where: { userId: user.id, status: { in: [SubscriptionStatus.ACTIVE, SubscriptionStatus.PAUSED] } }, data: { status: SubscriptionStatus.CANCELED, currentPeriodEnd: new Date() } });
        await tx.payment.updateMany({ where: { subscription: { userId: user.id, status: { in: [SubscriptionStatus.ACTIVE, SubscriptionStatus.PAUSED] } }, status: PaymentStatus.PENDING }, data: { status: PaymentStatus.CANCELED } });
      },
      { maxWait: this.MAX_WAIT, isolationLevel: Prisma.TransactionIsolationLevel.Serializable, timeout: this.TRANSACTION_TIMEOUT }
    );
    return this.createDefaultSubscription(userId);
  }

  static async cancel(userId: string) {
    const current = await this.getCurrentSubscription(userId);
    if (!current) throw new Error('No subscription found to cancel');
    await prisma.$transaction(
      async (tx) => {
        await tx.payment.updateMany({ where: { subscriptionId: current.id, status: PaymentStatus.PENDING }, data: { status: PaymentStatus.CANCELED } });
        await tx.subscription.update({ where: { id: current.id }, data: { status: SubscriptionStatus.CANCELED, currentPeriodEnd: new Date() } });
      },
      { maxWait: this.MAX_WAIT, isolationLevel: Prisma.TransactionIsolationLevel.Serializable, timeout: this.TRANSACTION_TIMEOUT }
    );
    return this.reset(userId);
  }

  static async updatePaymentStatus(userId: string, chargeId: string, status: PaymentStatus): Promise<void> {
    const current = await this.getCurrentSubscription(userId);
    if (!current) throw new Error('No active subscription found');
    const latest = await prisma.payment.findFirst({ where: { subscriptionId: current.id }, orderBy: { createdAt: 'desc' } });
    if (!latest) throw new Error('No pending payment found for this subscription');
    await prisma.$transaction(
      async (tx) => {
        await tx.payment.update({ where: { id: latest.id }, data: { status, chargeId, processedAt: new Date() } });
        if (status === PaymentStatus.SUCCEEDED) {
          await tx.subscription.update({ where: { id: current.id }, data: { status: SubscriptionStatus.ACTIVE } });
          await UsageManager.resetUsageCounts(current as any, userId);
        } else if (status === PaymentStatus.FAILED || status === PaymentStatus.CANCELED) {
          await tx.subscription.update({ where: { id: current.id }, data: { status: SubscriptionStatus.EXPIRED } });
        }
      },
      { maxWait: this.MAX_WAIT, isolationLevel: Prisma.TransactionIsolationLevel.Serializable, timeout: this.TRANSACTION_TIMEOUT }
    );
  }

  static async checkSubscriptionStatus(planName: string, userId: string, canceled?: boolean): Promise<'SUBSCRIBE' | 'RENEW' | 'UPDATE' | 'CANCEL'> {
    const current = await this.getCurrentSubscription(userId);
    if (canceled) return 'CANCEL';
    if (!current) return 'SUBSCRIBE';
    const currentPlanName = current.plan?.name;
    const isExpired = current.status === SubscriptionStatus.EXPIRED;
    if (isExpired || currentPlanName === planName) return 'RENEW';
    if (currentPlanName && currentPlanName !== planName) return 'UPDATE';
    return 'SUBSCRIBE';
  }

  static async checkAndManageCycle(userId: string) {
    const subscription = await this.getCurrentSubscription(userId);
    if (!subscription) throw new Error('No active subscription found');
    const now = DateTime.utc();
    const currentPeriodEnd = DateTime.fromJSDate(subscription.currentPeriodEnd).toUTC();
    const daysUntilExpiration = Math.floor(currentPeriodEnd.diff(now, 'days').days);
    const isExpired = now.toMillis() > currentPeriodEnd.toMillis();
    let nextCycleStart: Date | undefined;
    let nextCycleEnd: Date | undefined;
    if (subscription.status === SubscriptionStatus.ACTIVE) {
      nextCycleStart = currentPeriodEnd.toJSDate();
      nextCycleEnd = currentPeriodEnd.plus({ months: 1 }).toJSDate();
    }
    return {
      isExpired,
      daysUntilExpiration,
      isCycleTransition: now.startOf('day').toMillis() === currentPeriodEnd.startOf('day').toMillis(),
      currentCycleStart: subscription.currentPeriodStart,
      currentCycleEnd: subscription.currentPeriodEnd,
      nextCycleStart,
      nextCycleEnd
    };
  }

  static async handleCycleTransition(userId: string): Promise<void> {
    const cycle = await this.checkAndManageCycle(userId);
    const subscription = await this.getCurrentSubscription(userId);
    if (!subscription) throw new Error('No active subscription found');
    if (cycle.isExpired) {
      await UsageManager.resetUsageCounts(subscription as any, userId);
      if (subscription.plan.name === 'FREE') {
        const currentPeriodStart = DateTime.now().startOf('day');
        const currentPeriodEnd = currentPeriodStart.plus({ months: 1 });
        await this.updateCycleDates(userId, currentPeriodStart.toJSDate(), currentPeriodEnd.toJSDate());
        return;
      }
      const lastPayment = subscription.payments[subscription.payments.length - 1];
      if (lastPayment?.status === PaymentStatus.SUCCEEDED) {
        await this.renew(userId);
      }
    }
    if (cycle.isExpired && subscription.status !== SubscriptionStatus.EXPIRED) {
      await prisma.subscription.update({ where: { id: subscription.id }, data: { status: SubscriptionStatus.EXPIRED } });
    }
  }

  static async updateCycleDates(userId: string, newCurrentPeriodStart?: Date, newCurrentPeriodEnd?: Date): Promise<void> {
    const subscription = await this.getCurrentSubscription(userId);
    if (!subscription) throw new Error('No active subscription found');
    const updateData: any = {};
    if (newCurrentPeriodStart) {
      updateData.currentPeriodStart = newCurrentPeriodStart;
      if (!newCurrentPeriodEnd) {
        updateData.currentPeriodEnd = DateTime.fromJSDate(newCurrentPeriodStart).plus({ months: 1 }).toJSDate();
      }
    }
    if (newCurrentPeriodEnd) {
      updateData.currentPeriodEnd = newCurrentPeriodEnd;
      if (!newCurrentPeriodStart) {
        const proposed = DateTime.fromJSDate(newCurrentPeriodEnd).minus({ months: 1 });
        const currentStart = DateTime.fromJSDate(subscription.currentPeriodStart);
        updateData.currentPeriodStart = (proposed > currentStart ? proposed : currentStart).toJSDate();
      }
    }
    await prisma.$transaction(
      async (tx) => {
        await tx.subscription.update({ where: { id: subscription.id }, data: { ...updateData } });
        const currentPayment = await tx.payment.findFirst({ where: { subscriptionId: subscription.id, status: PaymentStatus.PENDING }, orderBy: { createdAt: 'desc' } });
        if (currentPayment) {
          await tx.payment.update({
            where: { id: currentPayment.id },
            data: {
              billingPeriodStart: updateData.currentPeriodStart || currentPayment.billingPeriodStart,
              billingPeriodEnd: updateData.currentPeriodEnd || currentPayment.billingPeriodEnd
            }
          });
        }
      },
      { maxWait: this.MAX_WAIT, isolationLevel: Prisma.TransactionIsolationLevel.Serializable, timeout: this.TRANSACTION_TIMEOUT }
    );
    const now = DateTime.utc();
    const newCycleStart = DateTime.fromJSDate(updateData.currentPeriodStart || subscription.currentPeriodStart).toUTC();
    if (now.startOf('day').toMillis() === newCycleStart.startOf('day').toMillis()) {
      await UsageManager.resetUsageCounts(subscription as any, userId);
    }
  }
}