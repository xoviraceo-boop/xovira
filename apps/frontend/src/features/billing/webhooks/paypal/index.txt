import { prisma } from '@/lib/prisma';
import { PaymentStatus, SubscriptionStatus } from '@xovira/types';
import { SubscriptionManager } from '@/features/billing/utils/subscriptionManager';
import { CreditManager } from '@/features/billing/utils/creditManager';
import crypto from 'crypto';

interface PayPalWebhookEvent {
  id: string;
  event_version: string;
  create_time: string;
  resource_type: string;
  event_type: string;
  summary: string;
  resource: any;
  links?: Array<{ href: string; rel: string; method: string }>;
}

export class PaypalWebhookManager {
  private constructor() {}

  /**
   * Verify PayPal webhook signature
   */
  static async verifyWebhookSignature(
    webhookId: string,
    headers: Record<string, string>,
    body: string
  ): Promise<boolean> {
    try {
      const transmissionId = headers['paypal-transmission-id'];
      const transmissionTime = headers['paypal-transmission-time'];
      const certUrl = headers['paypal-cert-url'];
      const transmissionSig = headers['paypal-transmission-sig'];
      const authAlgo = headers['paypal-auth-algo'];

      if (!transmissionId || !transmissionTime || !certUrl || !transmissionSig || !authAlgo) {
        console.error('Missing required webhook headers');
        return false;
      }

      // For production, verify with PayPal API
      // const response = await fetch(`${PAYPAL_API_BASE}/v1/notifications/verify-webhook-signature`, {
      //   method: 'POST',
      //   headers: {
      //     'Content-Type': 'application/json',
      //     'Authorization': `Bearer ${accessToken}`
      //   },
      //   body: JSON.stringify({
      //     transmission_id: transmissionId,
      //     transmission_time: transmissionTime,
      //     cert_url: certUrl,
      //     auth_algo: authAlgo,
      //     transmission_sig: transmissionSig,
      //     webhook_id: webhookId,
      //     webhook_event: JSON.parse(body)
      //   })
      // });
      // const verification = await response.json();
      // return verification.verification_status === 'SUCCESS';

      return true; // Skip verification in dev
    } catch (error) {
      console.error('Webhook signature verification failed:', error);
      return false;
    }
  }

  /**
   * Log webhook event
   */
  static async log(event: PayPalWebhookEvent) {
    try {
      const userId = this.extractUserId(event);
      await prisma.webhookLog.create({
        data: {
          topic: event.event_type,
          userId: userId || 'unknown',
          payload: event as any
        }
      });
    } catch (error) {
      console.error('Failed to log webhook:', error);
    }
  }

  /**
   * Queue webhook for processing
   */
  static async queueWebhook(event: PayPalWebhookEvent): Promise<void> {
    try {
      const userId = this.extractUserId(event);
      await prisma.webhookQueue.create({
        data: {
          topic: event.event_type,
          userId: userId || 'unknown',
          payload: event as any,
          status: 'pending',
          attempts: 0
        }
      });
    } catch (error) {
      console.error('Failed to queue webhook:', error);
      throw error;
    }
  }

  /**
   * Process webhook event
   */
  static async processWebhook(event: PayPalWebhookEvent): Promise<void> {
    await this.log(event);

    try {
      switch (event.event_type) {
        // Subscription lifecycle events
        case 'BILLING.SUBSCRIPTION.ACTIVATED':
          await this.handleSubscriptionActivated(event);
          break;
        
        case 'BILLING.SUBSCRIPTION.UPDATED':
          await this.handleSubscriptionUpdated(event);
          break;

        case 'BILLING.SUBSCRIPTION.CANCELLED':
          await this.handleSubscriptionCancelled(event);
          break;

        case 'BILLING.SUBSCRIPTION.SUSPENDED':
          await this.handleSubscriptionSuspended(event);
          break;

        case 'BILLING.SUBSCRIPTION.EXPIRED':
          await this.handleSubscriptionExpired(event);
          break;

        case 'BILLING.SUBSCRIPTION.RE-ACTIVATED':
          await this.handleSubscriptionReactivated(event);
          break;

        // Payment events
        case 'PAYMENT.SALE.COMPLETED':
          await this.handlePaymentCompleted(event);
          break;

        case 'PAYMENT.SALE.REFUNDED':
          await this.handlePaymentRefunded(event);
          break;

        case 'PAYMENT.SALE.REVERSED':
          await this.handlePaymentReversed(event);
          break;

        case 'PAYMENT.CAPTURE.COMPLETED':
          await this.handlePaymentCaptured(event);
          break;

        case 'PAYMENT.CAPTURE.DENIED':
          await this.handlePaymentDenied(event);
          break;

        case 'PAYMENT.CAPTURE.REFUNDED':
          await this.handlePaymentRefunded(event);
          break;

        default:
          console.log(`Unhandled webhook event type: ${event.event_type}`);
      }
    } catch (error) {
      console.error(`Error processing webhook ${event.event_type}:`, error);
      throw error;
    }
  }

  /**
   * Extract userId from event
   */
  private static extractUserId(event: PayPalWebhookEvent): string | null {
    return (
      event.resource?.custom_id ||
      event.resource?.subscriber?.payer_id ||
      event.resource?.payer?.payer_id ||
      null
    );
  }

  /**
   * Handle subscription activated
   */
  static async handleSubscriptionActivated(event: PayPalWebhookEvent) {
    console.log("this is event", event)
    const userId = this.extractUserId(event);
    const subscriptionId = event.resource?.id;
    const planId = event.resource?.plan_id;

    if (!userId || !subscriptionId) {
      console.error('Missing userId or subscriptionId in activation event');
      return;
    }

    try {
      await SubscriptionManager.activate(userId, {
        subscriptionId,
        status: SubscriptionStatus.ACTIVE,
        planId: planId,
        providerName: 'PAYPAL',
        createdAt: event.resource?.create_time,
        updatedAt: event.resource?.update_time,
        metadata: {
          provider: 'PAYPAL',
          paypalSubscriptionId: subscriptionId,
          paypalPlanId: planId,
          webhookEventId: event.id
        }
      });
    } catch (error) {
      console.error('Failed handling PayPal subscription activation:', error);
      throw error;
    }
  }

  /**
   * Handle subscription updated
   */
  static async handleSubscriptionUpdated(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    if (!userId) return;

    // Update subscription details if needed
    console.log('Subscription updated:', event.resource?.id);
  }

  /**
   * Handle subscription cancelled
   */
  static async handleSubscriptionCancelled(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    if (!userId) return;

    await SubscriptionManager.cancel(userId);
  }

  /**
   * Handle subscription suspended
   */
  static async handleSubscriptionSuspended(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    if (!userId) return;

    await SubscriptionManager.freeze(userId);
  }

  /**
   * Handle subscription expired
   */
  static async handleSubscriptionExpired(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    if (!userId) return;

    const subscription = await SubscriptionManager.getCurrentSubscription(userId);
    if (subscription) {
      await prisma.subscription.update({
        where: { id: subscription.id },
        data: { 
          status: SubscriptionStatus.EXPIRED,
          currentPeriodEnd: new Date()
        }
      });
    }
  }

  /**
   * Handle subscription reactivated
   */
  static async handleSubscriptionReactivated(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    if (!userId) return;

    await SubscriptionManager.unfreeze(userId);
  }

  /**
   * Handle payment completed (recurring payment)
   */
  static async handlePaymentCompleted(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    const chargeId = event.resource?.id;
    
    if (!userId || !chargeId) {
      console.error('Missing userId or chargeId in payment completion event');
      return;
    }

    await SubscriptionManager.updatePaymentStatus(
      userId,
      String(chargeId),
      PaymentStatus.SUCCEEDED
    );

    // Renew subscription for next cycle
    const subscription = await SubscriptionManager.getCurrentSubscription(userId);
    if (subscription && subscription.plan.name !== 'FREE') {
      await SubscriptionManager.renew(userId);
    }
  }

  /**
   * Handle payment captured
   */
  static async handlePaymentCaptured(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    const chargeId = event.resource?.id;
    
    if (!userId || !chargeId) return;

    // If capture relates to a one-time order, attempt to grant credits
    try {
      const packageId = event.resource?.supplementary_data?.related_ids?.order_id || event.resource?.invoice_id;
      const email = event?.resource?.payer?.email_address;
      const userName = event?.resource?.payer?.name?.given_name || '';
      if (packageId) {
        await CreditManager.purchaseCreditsWithPromotions(
          userId,
          userName,
          packageId,
          String(chargeId),
          email
        );
        return;
      }
    } catch (e) {
      console.warn('PayPal credit purchase grant failed, falling back to subscription status update');
    }

    await SubscriptionManager.updatePaymentStatus(
      userId,
      String(chargeId),
      PaymentStatus.SUCCEEDED
    );
  }

  /**
   * Handle payment denied
   */
  static async handlePaymentDenied(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    const chargeId = event.resource?.id;
    
    if (!userId || !chargeId) return;

    await SubscriptionManager.updatePaymentStatus(
      userId,
      String(chargeId),
      PaymentStatus.FAILED
    );
  }

  /**
   * Handle payment refunded
   */
  static async handlePaymentRefunded(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    const chargeId = event.resource?.sale_id || event.resource?.id;
    
    if (!userId || !chargeId) return;

    await SubscriptionManager.updatePaymentStatus(
      userId,
      String(chargeId),
      PaymentStatus.REFUNDED
    );
  }

  /**
   * Handle payment reversed (chargeback)
   */
  static async handlePaymentReversed(event: PayPalWebhookEvent) {
    const userId = this.extractUserId(event);
    const chargeId = event.resource?.id;
    
    if (!userId || !chargeId) return;

    await SubscriptionManager.updatePaymentStatus(
      userId,
      String(chargeId),
      PaymentStatus.FAILED
    );

    // Suspend subscription due to chargeback
    await SubscriptionManager.freeze(userId);
  }

  /**
   * Process queued webhooks
   */
  static async processQueue(limit: number = 10): Promise<void> {
    const pendingWebhooks = await prisma.webhookQueue.findMany({
        where: {
        status: 'pending',
        attempts: { lt: 3 }
      },
      take: limit,
      orderBy: { createdAt: 'asc' }
    });

    for (const webhook of pendingWebhooks) {
      try {
        await this.processWebhook(webhook.payload as any);
        
        await prisma.webhookQueue.update({
          where: { id: webhook.id },
          data: {
            status: 'processed',
            processedAt: new Date()
          }
        });
      } catch (error: any) {
        await prisma.webhookQueue.update({
          where: { id: webhook.id },
          data: {
            attempts: webhook.attempts + 1,
            error: error.message,
            status: webhook.attempts + 1 >= 3 ? 'failed' : 'pending'
          }
        });
      }
    }
  }

  /**
   * Retry failed webhooks
   */
  static async retryFailed(): Promise<void> {
    await prisma.webhookQueue.updateMany({
          where: { 
        status: 'failed',
        attempts: { lt: 5 }
          },
          data: {
        status: 'pending'
      }
    });
  }
}